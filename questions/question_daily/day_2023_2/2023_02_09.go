package day_2023_02

import "fmt"

// 这题并非 Go 独有，而是计算机的基础。比如相应的 C 语言程序，结果和 Go 对应程序是一样的。

func Day_2023_02_09() {
	// 第一题是 -128（untyped const）/ -1 (int8 var)，untyped 隐式转换为 int8，
	// 刚好在范围内，结果是 128 ，溢出 int8 的范围。
	// 因为结果不是常量，允许溢出，最高位为符号位，变成了补码，刚好又是 -128。
	/*
		因为 var b int8 = -128 / a 不是常量表达式，因此 untyped 常量 -128 隐式转换为 int8 类型（即和 a 的类型一致），
		所以 -128 / a 的结果是 int8 类型，值是 128，超出了 int8 的范围。
		因为结果不是常量，允许溢出，128 的二进制表示是 10000000，正好是 -128 的补码。所以，第一题的结果是 -128。
	*/
	var a int8 = -1
	var b int8 = -128 / a

	// -128
	fmt.Println(b)
}

// 第二题 -128 和 -1 都是 const，直接在编译时求值，untyped 的 -128 隐式转 int8，结果为 128，仍然是一个 const。
// const 转换时不允许溢出，编译错误。

/*
	对于 var b int8 = -128 / a，因为 a 是 int8 类型常量，所以 -128 / a 是常量表达式，在编译器计算，结果必然也是常量。
	因为 a 的类型是 int8，因此 -128 也会隐式转为 int8 类型，128 这个结果超过了 int8 的范围，但常量不允许溢出，因此编译报错。
*/
// 编译错误
// func Day_2023_02_09_02() {
// 	const a int8 = -1
// 	var b int8 = -128 / a

// 	fmt.Println(b)
// }
